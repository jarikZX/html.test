<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Моя страница</title>
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="#">меню 1</a></li>
                <li><a href="#">меню 2</a></li>
            </ul>
        </nav>
    </header>
 <h1>Нотация описания архитектуры приложения</h1>
 <h2>Мотивация</h2>
 <p>Я, как технический директор , регулярно сталкиваюсь с необходимостью обсудить с командой архитектуру нового приложения
или микросервиса. И в рамках таких обсуждений я понял, что не существует единого подхода, который позволил бы эффективно
общаться команде, обсуждая архитектурные решения.</p>

<p>Понятно, что на словах это не объяснишь и приходится прибегать к дополнительным инструментам в виде доски и маркера или
же при текущих реалиях - online доски типа <a href="https://miro.com/ru/" target="_blank">Miro</a>. Но даже в этом случае обсуждение сваливается в хаотично нарисованные
квадратики, круги или прямоугольники с текстом, как-то соединённые стрелками.</p>
<p>При этом от обсуждения к обсуждению <sup>1</sup> одна и так же схема может быть нарисована 1000 разными способами<sub>2</sub>. Кто-то в
творческом порыве начинает рисовать иконки пользователей или серверов, а кто-то рисует поток из 10 стрелок, чтобы
показать все возможные варианты взаимодействия. И это - не эффективная коммуникация, где одно и тоже можно понять
по-разному при этом потратив какое-то время на пояснение чем шестиугольник отличается круга.</p>
<h2>А что есть?</h2>
<hr>
<p>Осознав проблемы я первым делом начал искать готовые варианты. Вот несколько из них:</p>
<ul>
    <li>Диаграмма классов - иногда бывает удобной для анализа уже существующего кода, но не применима для изначального
    проектирования, где мы оперируем более верхне уровневыми объектами.</li>
    <li>c4model - уже ближе к теме и предлагает 4 уровня детализации схемы программного обеспечения. Но часто из всех 4-х
    уровней подходит 3-й, когда мы планируем новый сервис, а на 3-м уровне стандартов описания немного. Отлично подходит для
    верхнего уровня описания системы, но при детализации на компоненты не имеет детальных стандартов.</li>
</ul>
<p>Потому после нескольких экспериментов, я решил подготовить простую нотацию, которая позволит описать архитектуру
приложений на том уровне, чтобы мы могли:</p>
<ul>
    <li>Разбить создание его на задачи.</li>
    <li>Проверить корректность деления на модули, чтобы сократить их связанность.</li>
    <li>Упростить коммуникацию в команде при обсуждении деталей проектирования приложения.</li>
    <li>Использовать её для документирования архитектуры как монолита, так и микросервисов.</li>
</ul>
<h2>Требования к нотации</h2>
<p>Перед тем, как переходить к описанию предлагаемой нотации следует сформулировать требования, которым она должна
удовлетворять:</p>
<ul>
    <li>Она должна на верхнем уровне описывать отделимые части системы, которые далее я буду назвать «компоненты».</li>
    <li>Связи между ними должны описать зависимости и поток вызовов, но не быть слишком усложнены. По связям должно быть сразу
    понятно наличии архитектурных ошибок.</li>
    <li>Схема должна подходить как для описания монолитного приложения, так и микросервисной архитектору.</li>
    <li>Фокус должен быть на описании нашей архитектуры, максимально абстрагировавшись от внешних систем.</li>
</ul>
<p>Ниже будет написано мое видение такой нотации с учётом опыта тестирования её вместе с командой. На практике она
позволила в кратчайшие сроки обсуждать изменения в архитектуре или планировать полноценные новые сервисы или приложения.</p>
<h2>Компоненты</h2>
<p>Стоит начать рассмотрение именно с компонент, так как они являются строительными блоками всей нашей диаграммы. Это
изолированный с точки зрения логики кусок кода, который может в реальности представлять собой класс или отдельный файл.</p>
<p>Это может быть:</p>
<ul>
    <li>Контроллер, которые обрабатывает входящие запросы.</li>
    <li>Сервис, отвечающий за бизнес логику работы с платежами.</li>
    <li>Репозиторий, взаимодействующий с базой данных.</li>
    <li>Обработчик event событий при использовании event sourcing.</li>
    <li>Бизнес entity пользователя, содержащие поля для него и методы работы.</li>
</ul>
<p>Фактически все, что вы можете выделить в виде класса с инкапсулированной логикой - это компонент.</p>
<p>Для того чтобы максимально полно описать компонент можно указать следующие параметры:</p>
<ul>
    <li>Имя - название компонента, отражающие его суть или даже название класса</li>
    <li>Тип - чтобы понять что это контроллер или репозиторий</li>
    <li>Пояснение - если требуется дополнительное описание.</li>
</ul>
<p>Примеры:</p>
<img src="./img/image1.jpg" alt="пример оформления блоков в архитектуре" />
<section>
    <table>
        <caption>Структура рассходов</caption>
        <thead>
            <tr>
                <th rowspan="2">статья</th>
                <th colspan="2">сумма</th>
            </tr>
            <tr>
                <th>Руб</th>
                <th>$</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Зарплата</td>
                <td>100 000р</td>
                <td>2 000</td>
            </tr>
            <tr>
                <td>сервисы</td>
                <td>30 000</td>
                <td>500</td>
            </tr>
        </tbody>
        <tfoot>
            <td>итог</td>
            <td>130 000</td>
            <td>2 500</td>
        </tfoot>
        
    </table>
</section>
<main></main>
<footer>футер</footer>
</body>
</html>